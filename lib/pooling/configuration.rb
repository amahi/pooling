# Amahi Home Server
# Copyright (C) 2007-2013 Amahi Team
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License v3
# (29 June 2007), as published in the COPYING file.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# file COPYING for more details.
#
# You should have received a copy of the GNU General Public
# License along with this program; if not, write to the Amahi
# team at http://www.amahi.org/ under "Contact Us."

require 'yaml'

# Driver for Greyhole http://greyhole.pommepause.com/
module Pooling
	class Configuration
		SUFFIX = "gh"
		USE_DOT_FILE = ".greyhole_uses_this"

		GH_DEFAULTS = { "delete_moves_to_trash" => "yes",
				"modified_moves_to_trash" => "no",
				"email_to" => "root",
				"drive_selection_algorithm" => "most_available_space",
				"db_engine" => "mysql",
				"db_host" => "localhost", "db_user" => "greyhole", "db_pass" => "greyhole", "db_name" => "greyhole",
				"sticky_files" => { "Music/" => nil },
				"greyhole_log_file" => "/var/log/greyhole.log",
				"df_cache_time" => "15",
				"log_memory_usage" => "no",
				"check_for_open_files" => "yes",
				"ignored_files" => '(\..*\.[0-9a-zA-Z]{6}|[0-9A-F]{8}\.tmp|\.cprestoretmp.*)',
				"ignored_folders" => '.*/_UNPACK_.*',
				"log_level" => "INFO",
				"other" => nil }
		GH_DEFAULTS_FILE = "#{Rails.root}/config/greyhole.yml"

		# generate and write GH conf file
		def self.save_conf_file(partitions, shares)
			ghconf = "#{Rails.root}/tmp/greyhole-%d.%d" % [$$, rand(99999)]
			s = File.new ghconf, "w"
			s.write(self.greyhole_conf(partitions, shares))
			s.flush
			s.close
			c = Command.new
			c.submit("cp \"#{ghconf}\" /etc/greyhole.conf")
			c.submit("rm -f \"#{ghconf}\"")
			partitions.each do |p|
				ppath = part_path p
				# ensure it's a mountpoint - http://bugs.amahi.org/issues/show/611
				if Pathname.new(p.path).mountpoint?
					c.submit("mkdir -p \"#{ppath}\"")
					c.submit("touch \"#{ppath}/#{USE_DOT_FILE}\"")
				end
			end
			# reload greyhole, if it was running
			c.submit("systemctl condrestart amahi-greyhole.service")
			c.execute
		end

		def self.enabled?
			File.exist? "/etc/greyhole.conf"
		end

	private

		# Generate GH conf file
		def self.greyhole_conf(partitions, shares)
			ret = self.header
			partitions.each do |p|
				# ensure it's a mountpoint
				ret += self.partition_conf(p) if Pathname.new(p.path).mountpoint?
			end
			shares.each do |s|
				ret += self.share_conf(s)
			end
			ret
		end

		def self.share_conf(s)
			name = s.name
			copies = s.disk_pool_copies
			copies = "max" if copies == 999
			"num_copies[#{name}] = #{copies}\n"
		end

		def self.partition_conf(p)
			"storage_pool_directory = #{part_path p}, min_free: #{p[:minimum_free]}gb\n"
		end

		def self.part_path(p)
			File.join(p[:path], SUFFIX)
		end

		def self.header
			gh = GH_DEFAULTS
			begin
				gh.merge!(YAML::load(File.open(GH_DEFAULTS_FILE))) if File.exists?(GH_DEFAULTS_FILE)
			rescue
				# shh - fail silently instead of crashing
			end
			# mysql settings
			mysql = ['db_host', 'db_user', 'db_pass', 'db_name'].map{|s| "#{s} = #{gh[s]}" }.join("\n")
			settings = ["# This file is automatically generated by Amahi on #{Time.now}",
				"# Any manual changes WILL BE OVERWRITTEN!",
				"# Set the defaults (carefully) in #{GH_DEFAULTS_FILE}",
				"db_engine = #{gh['db_engine']}",
				((gh['db_engine'] == 'sqlite') ? "db_path = #{gh['db_path']}" : mysql)]
			gh.delete_if { |k, _| k =~ /^db_/ }
			settings << sticky_files_to_s(gh["sticky_files"])
			if gh['other']
				settings << gh['other']
				settings << ['']
			end
			gh.delete_if { |k, _| k =~ /^(sticky_files|other)$/ }
			# save the rest of the settings above
			gh.each do |k, v|
				settings << ["#{k} = #{v}"]
			end
			settings.join "\n"
		end

		def self.sticky_files_to_s(data)
			# new format!
			res = []
			data.map do |entry|
				pattern = entry[0]
				into = entry[1]
				res << "sticky_files = #{pattern}"
				res += into.map{ |dir| "\tstick_into = #{dir}" } if into
			end
			res
		end
	end
end
