# Amahi Home Server
# Copyright (C) 2007-2013 Amahi
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License v3
# (29 June 2007), as published in the COPYING file.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# file COPYING for more details.
#
# You should have received a copy of the GNU General Public
# License along with this program; if not, write to the Amahi
# team at http://www.amahi.org/ under "Contact Us."
require 'fileutils'
class DiskPoolShare < ActiveRecord::Base
	belongs_to :share
	SIGNATURE = "Amahi configuration"
	def toggle_pooling!
		self.pooling = !self.pooling
		self.save!
		Pooling::Configuration.save_conf_file(DiskPoolPartition.all, DiskPoolShare.in_disk_pool)
	end

	def update_extra_copies(value)
		self.extra_copies =  value
		self.save!
		Pooling::Configuration.save_conf_file(DiskPoolPartition.all, DiskPoolShare.in_disk_pool)
		DiskPoolShare.push_shares
	end

	def self.in_disk_pool
		share_ids = DiskPoolShare.where("extra_copies>0").map{|pool| pool.share_id}
		shares = []
		share_ids.each do |share_id|
			share = Share.where(:id=>share_id).first
			if share
				shares << share
			else
				DiskPoolShare.where(:share_id=>share_id).first.destroy!
			end
		end
		shares
	end
	def self.push_shares
		domain = Setting.value_by_name "domain"
		debug = Setting.shares.value_by_name('debug') == '1'

		smbconf = TempCache.unique_filename "smbconf"
		File.open(smbconf, "w") do |l|
			l.write(self.samba_conf(domain))
		end

		lmhosts = TempCache.unique_filename "lmhosts"
		File.open(lmhosts, "w") do |l|
			l.write(self.samba_lmhosts(domain))
		end

		# copy files to the samba area
		time = Time.now
		c = Command.new
		c.submit("cp /etc/samba/smb.conf \"/tmp/smb.conf.#{time}\"") if debug
		c.submit("cp #{smbconf} /etc/samba/smb.conf")
		c.submit("rm -f #{smbconf}")

		c.submit("cp /etc/samba/lmhosts \"/tmp/lmhosts.#{time}\"") if debug
		c.submit("cp #{lmhosts} /etc/samba/lmhosts")
		c.submit("rm -f #{lmhosts}")

		c.execute

		# reload the server - nmbd will do it on it's own!
		Platform.reload(:nmb)
	end

	def self.samba_conf(domain)
		ret = self.header(domain)
		Share.all.each do |s|
			ret += self.share_conf(s)
		end
		ret
	end

	def self.samba_lmhosts(domain)
		ip = Setting.value_by_name('net') + '.' + Setting.value_by_name('self-address')
		ret = ["# This file is automatically generated. Any manual changes MAY BE OVERWRITTEN\n# #{SIGNATURE}, generated on #{Time.now}",
			"127.0.0.1 localhost",
			"%s hda",
			"%s files",
			"%s hda.%s",
		"%s files.%s"].join "\n"
		ret % [ip, ip, ip, domain, ip, domain]
	end

	def self.share_conf(s)
		ret = "[%s]\n"		\
		"\tcomment = %s\n" 	\
		"\tpath = %s\n" 	\
		"\twriteable = %s\n" 	\
		"\tbrowseable = %s\n%s%s%s%s\n"
		wr = s.rdonly ? "no" : "yes"
		br = s.visible ? "yes" : "no"
		allowed  = ''
		writes  = ''
		masks = "\tcreate mask = 0775\n"
		masks += "\tforce create mode = 0664\n"
		masks += "\tdirectory mask = 0775\n"
		masks += "\tforce directory mode = 0775\n"
		unless s.everyone
			allowed = "\tvalid users = "
			writes = "\twrite list = "
			u = s.users_with_share_access.map{ |acc| acc.login } rescue nil
			w = s.users_with_write_access.select{ |wrt| u.include?(wrt.login) }.map{ |user| user.login } rescue nil
			u = ['nobody'] if !u or u.empty?
			u |= ['nobody'] if s.guest_access
			allowed += u.join(', ') + "\n"
			w = ['nobody'] if !w or w.empty?
			w |= ['nobody'] if s.guest_writeable
			writes += w.join(', ') + "\n"
		end
		if (s.guest_access || s.guest_writeable) && !s.everyone
			writes += "\tguest ok = yes\n"
		end
		e = ""
		e = "\t" + (s.extras.gsub /\n/, "\n\t") unless s.extras.nil?
		pool = DiskPoolShare.where(:share_id=>s.id).first
		if pool.extra_copies > 0
			tmp = e.gsub /\tdfree command.*\n/, ''
			e = tmp.gsub /\tvfs objects.*greyhole.*\n/, ''
			e += "\n\t" + 'dfree command = /usr/bin/greyhole-dfree' + "\n"
			e += "\t" + 'vfs objects = greyhole' + "\n"
		end
		ret % [s.name, s.name, s.path, wr, br, allowed, writes, masks, e]
	end

	def self.header_workgroup(domain)
		short_domain = Setting.find_or_create_by(Setting::GENERAL, 'workgroup', 'WORKGROUP').value
		debug = Setting.shares.value_by_name('debug') == '1'
		win98 = Setting.shares.value_by_name('win98') == '1'
		ret = ["# This file is automatically generated for WORKGROUP setup.",
			"# Any manual changes MAY BE OVERWRITTEN\n# #{SIGNATURE}, generated on #{Time.now}",
			"[global]",
			"\tworkgroup = %s",
			"\tserver string = %s",
			"\tnetbios name = hda",
			"\tprinting = cups",
			"\tprintcap name = cups",
			"\tload printers = yes",
			"\tcups options = raw",
			"\tlog file = /var/log/samba/%%m.log",
			"\tlog level = #{debug ? 5 : 0}",
			"\tmax log size = 150",
			"\tpreferred master = yes",
			"\tos level = 60",
			"\ttime server = yes",
			"\tunix extensions = no",
			"\twide links = yes",
			"\tsecurity = user",
			"\tusername map script = /usr/share/hda-platform/hda-usermap",
			"\tlarge readwrite = yes",
			"\tencrypt passwords = yes",
			"\tdos charset = CP850",
			"\tunix charset = UTF8",
			"\tguest account = nobody",
			"\tmap to guest = Bad User",
			"\twins support = yes",
			win98 ? "client lanman auth = yes" : "",
			"",
			"[homes]",
			"\tcomment = Home Directories",
			"\tvalid users = %%S",
			"\tbrowseable = no",
			"\twritable = yes",
			"\tcreate mask = 0644",
		"\tdirectory mask = 0755"].join "\n"
		ret % [short_domain, domain]
	end

	def self.header_pdc(domain)
		short_domain = Setting.shares.value_by_name("workgroup") || 'workgroup'
		debug = Setting.shares.value_by_name('debug') == '1'
		admins = User.admins rescue ["no_such_user"]
		ret = ["# This file is automatically generated for PDC setup.",
			"# Any manual changes MAY BE OVERWRITTEN\n# #{SIGNATURE}, generated on #{Time.now}",
			"[global]",
			"\tworkgroup = %s",
			"\tserver string = %s",
			"\tnetbios name = hda",
			"\tprinting = cups",
			"\tprintcap name = cups",
			"\tload printers = yes",
			"\tcups options = raw",
			"\tlog file = /var/log/samba/%%m.log",
			"\tlog level = #{debug ? 5 : 0}",
			"\tmax log size = 150",
			"\tpreferred master = yes",
			"\tos level = 65",
			"\tdomain master = yes",
			"\tlocal master = yes",
			"\tadmin users = #{admins.map{|u| u.login}.join ', '}",
			"\tdomain logons = yes",
			"\tlogon path = \\\\%%L\\profiles\\%%U",
			"\tlogon drive = q:",
			"\tlogon home = \\\\%%N\\%%U",
			"\ttime server = yes",
			"\tunix extensions = no",
			"\twide links = yes",
			"\tsecurity = user",
			"\tusername map script = /usr/share/hda-platform/hda-usermap ",
			"\tlarge readwrite = yes",
			"\tencrypt passwords = yes",
			"\tdos charset = CP850",
			"\tunix charset = UTF8",
			"\tguest account = nobody",
			"\tmap to guest = Bad User",
			"\twins support = yes",
			"\tlogon script = %%U.bat",
			"\t# FIXME - is 99 (nobody) the right group?",
			"\tadd machine script = /usr/sbin/useradd -d /dev/null -g 99 -s /bin/false -M %%u",
			"",
			"[netlogon]",
			"\tpath = #{PDC_SETTINGS}/netlogon",
			"\tguest ok = yes",
			"\twritable = no",
			"\tshare modes = no",
			"",
			"[profiles]",
			"\tpath = #{PDC_SETTINGS}/profiles",
			"\twritable = yes",
			"\tbrowseable = no",
			"\tread only = no",
			"\tcreate mode = 0777",
			"\tdirectory mode = 0777",
			"",
			"[homes]",
			"\tcomment = Home Directories",
			"\tread only = no",
			"\twriteable = yes",
			"\tbrowseable = yes",
			"\tcreate mask = 0640",
			"\tdirectory mask = 0750",
		"\n"].join "\n"
		ret % [short_domain, domain]
	end

	def self.header_common
		["",
			"[print$]",
			"\tpath = /var/lib/samba/drivers",
			"\tread only = yes",
			"\tforce group = root",
			"\twrite list = @ntadmin root",
			"\tforce group = root",
			"\tcreate mask = 0664",
			"\tdirectory mask = 0775",
			"\tguest ok = yes",
			"",
			"[printers]",
			"\tpath = /var/spool/samba",
			"\twriteable = yes",
			"\tbrowseable = yes",
			"\tprintable = yes",
		"\tpublic = yes\n\n"].join("\n")
	end

	def self.header(domain)
		pdc = Setting.shares.value_by_name('pdc') == '1'
		h = pdc ? header_pdc(domain) : header_workgroup(domain)
		h + "\n" + self.header_common
	end
end
